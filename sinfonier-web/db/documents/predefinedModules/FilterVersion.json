{
   "versionTag":"1.0",
   "versionCode":1,
   "status":"predefined",
   "sourceType":"template",
   "sourceCode":"package com.sinfonier.bolts;\r\n\r\nimport java.util.Collection;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.regex.Pattern;\r\n\r\nimport com.sinfonier.exception.FilterBoltException;\r\n\r\n//@formatter:off\r\n/**\r\n* Filter an entity. \r\n* \u003cp\u003e XML Options:\u003cbr/\u003e\r\n* \u003cul\u003e\r\n* \u003cli\u003e \u003cb\u003e{@code \u003csources\u003e \u003csource\u003e \u003csourceId\u003e\u003c/sourceId\u003e \u003cgrouping field=\"field\"\u003e\u003c/grouping\u003e \u003c/source\u003e ... \u003c/sources\u003e}\u003c/b\u003e - Needed. Sources where this bolt must receive tuples. \u003c/li\u003e\r\n* \u003cli\u003e \u003cb\u003e{@code \u003caction\u003e\u003c/action\u003e}\u003c/b\u003e - Optional. Values: Permit, Block. Default Permit.\u003c/li\u003e\r\n* \u003cli\u003e \u003cb\u003e{@code \u003cmatch\u003e\u003c/match\u003e}\u003c/b\u003e - Needed. Values: Any, All. Other value =\u003e Default All. \u003c/li\u003e\r\n* \u003cli\u003e \u003cb\u003e{@code \u003cconditions\u003e \u003ccondition\u003e \u003cfield\u003e\u003c/field\u003e\u003coperator\u003e\u003c/operator\u003e\u003cvalue\u003e\u003c/value\u003e \u003c/condition\u003e .. \u003c/conditions\u003e}\u003c/b\u003e - Needed. Filters. \u003c/li\u003e\r\n* \u003cli\u003e \u003cb\u003e{@code \u003centity\u003e\u003c/entity\u003e}\u003c/b\u003e - Optional. Entity, in case you want to change it. \u003c/li\u003e\r\n* \u003cli\u003e \u003cb\u003e{@code \u003cnumTasks\u003e\u003c/numTasks\u003e}\u003c/b\u003e - Optional. Num tasks of this bolt. \u003c/li\u003e\r\n* \u003cli\u003e \u003cb\u003e{@code \u003cparalellism\u003e1\u003c/paralellism\u003e }\u003c/b\u003e - Needed. Parallelism. \u003c/li\u003e\r\n* \u003c/ul\u003e\r\n*/\r\n//@formatter:on\r\npublic class Filter extends BaseSinfonierBolt {\r\n\r\n    private static final long serialVersionUID = -1468919746895350525L;\r\n    private boolean permit = true;\r\n    private boolean all = true;\r\n    private List\u003cMap\u003cString, Object\u003e\u003e conditions;\r\n\r\n    public Filter(String xmlFile) {\r\n        super(xmlFile);\r\n    }\r\n\r\n    @Override\r\n    public void userprepare() {\r\n        String action = getParam(\"action\").trim();\r\n        if (action.equalsIgnoreCase(\"block\")) {\r\n            permit = false;\r\n        }\r\n        String match = getParam(\"match\", true).trim().toLowerCase();\r\n        if (match.equalsIgnoreCase(\"any\")) {\r\n            all = false;\r\n        }\r\n\r\n        conditions = getComplexProperty(\"conditions\");\r\n    }\r\n\r\n    @Override\r\n    public void userexecute() {\r\n        boolean emit = isPermit() ? processPermit() : processBlock();\r\n\r\n        if (emit) {\r\n            emit();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public void usercleanup() {\r\n\r\n    }\r\n\r\n    // Possible operators, contains, does not contain, matches regex, \u003e, \u003c, ==,\r\n    @SuppressWarnings(\"rawtypes\")\r\n    private boolean doComparation(Map\u003cString, Object\u003e condition) {\r\n        String field = (String) condition.get(\"field\");\r\n        String operator = (String) condition.get(\"operator\");\r\n        String value = String.valueOf(condition.get(\"value\"));\r\n\r\n        Object jsonField = getField(field);\r\n\r\n        if (jsonField == null) {\r\n            return false;\r\n        }\r\n\r\n        boolean result = false;\r\n\r\n        switch (operator) {\r\n        case \"\u003c\":\r\n            result = compare(jsonField, value) \u003c 0;\r\n            break;\r\n        case \"\u003c=\":\r\n            result = compare(jsonField, value) \u003c= 0;\r\n            break;\r\n        case \"\u003e\":\r\n            result = compare(jsonField, value) \u003e 0;\r\n            break;\r\n        case \"\u003e=\":\r\n            result = compare(jsonField, value) \u003e= 0;\r\n            break;\r\n        case \"==\":\r\n            result = jsonField.equals(value);\r\n            break;\r\n        case \"!=\":\r\n            result = !jsonField.equals(value);\r\n            break;\r\n        case \"match\": // Matches regex\r\n            result = Pattern.matches((String) getJson().get(field), value);\r\n            break;\r\n        case \"containsText\":\r\n            result = ((String) jsonField).contains(value);\r\n            break;\r\n        case \"contains\":\r\n            if (jsonField instanceof Collection) {\r\n                result = ((Collection) jsonField).contains(value);\r\n            } else if (jsonField instanceof String) {\r\n                result = ((String) jsonField).contains(value);\r\n            } else {\r\n                throw new FilterBoltException(\"Cannot check contains in field \"\r\n                        + getJson().get(field));\r\n            }\r\n            break;\r\n        case \"notcontains\":\r\n            if (jsonField instanceof Collection) {\r\n                result = !((Collection) jsonField).contains(value);\r\n            } else if (jsonField instanceof String) {\r\n                result = !((String) jsonField).contains(value);\r\n            } else {\r\n                throw new FilterBoltException(\"Cannot check contains in field \" + jsonField);\r\n            }\r\n            break;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    public int compare(Object field, String value) {\r\n        return new Double(String.valueOf(field)).compareTo(Double.parseDouble(value));\r\n    }\r\n\r\n    /**\r\n     * Process Permit filter.\r\n     *\r\n     * @return {@code true} if current tuple must be emitted.\r\n     */\r\n    public boolean processPermit() {\r\n        boolean emit = isAll();\r\n\r\n        for (Map\u003cString, Object\u003e condition : conditions) {\r\n            boolean result = doComparation(condition);\r\n            if (isAll() \u0026\u0026 !result) {\r\n                emit = false;\r\n                break;\r\n            } else if (isAny() \u0026\u0026 result) {\r\n                emit = true;\r\n                break;\r\n            }\r\n        }\r\n        return emit;\r\n    }\r\n\r\n    /**\r\n     * Process Block filter.\r\n     *\r\n     * @return {@code true} if current tuple must be emitted.\r\n     */\r\n    public boolean processBlock() {\r\n        boolean emit = !isAll();\r\n\r\n        for (Map\u003cString, Object\u003e condition : conditions) {\r\n            boolean result = doComparation(condition);\r\n            if (isAll() \u0026\u0026 !result) {\r\n                emit = true;\r\n                break;\r\n            } else if (isAny() \u0026\u0026 result) {\r\n                emit = false;\r\n                break;\r\n            }\r\n        }\r\n        return emit;\r\n    }\r\n\r\n    public boolean isPermit() {\r\n        return permit;\r\n    }\r\n\r\n    public boolean isBlock() {\r\n        return !permit;\r\n    }\r\n\r\n    public boolean isAll() {\r\n        return all;\r\n    }\r\n\r\n    public boolean isAny() {\r\n        return !all;\r\n    }\r\n}",
   "sourceCodeUrl":"",
   "description":"Input parameters filtered following several rules",
   "created_at":{
      "$date":"2016-09-01T00:00:00.000Z"
   },
   "updated_at":{
      "$date":"2016-09-01T00:00:00.000Z"
   },
   "singleton":false,
   "topologies_count":0,
   "ticktuple":null,
   "fields":[
      {
         "name":"#",
         "label":"",
         "type":"combine",
         "required":false,
         "wirable":false,
         "fields":[
            {
               "name":"action",
               "type":"select",
               "typeInvite":" ",
               "choices":[
                  "Permit",
                  "Block"
               ]
            },
            {
               "name":"match",
               "type":"select",
               "typeInvite":" ",
               "choices":[
                  "Any",
                  "All"
               ]
            }
         ],
         "separators":[
            false,
            "&nbsp; items that match",
            "&nbsp; of the following"
         ]
      },
      {
         "name":"conditions",
         "label":"Rules",
         "type":"list", 
         "required":false,
         "wirable":false,
         "elementType":{
            "name":"condition",
            "type":"combine",
            "fields":[
               {
                  "name":"field",
                  "type":"string",
                  "typeInvite":"field"
               },
               {
                  "name":"operator",
                  "type":"select",
                  "typeInvite":"",
                  "choices":[
                     "<",
                     "<=",
                     ">",
                     ">=",
                     "==",
                     "!=",
                     "match",
                     "contains",
                     "not contains"
                  ]
               },
               {
                  "name":"value",
                  "type":"string",
                  "typeInvite":"value"
               }
            ],
            "separators":[
               false,
               "&nbsp;&nbsp;",
               "&nbsp;&nbsp;",
               false
            ]
         }
      }
   ],
   "container":{
      "xtype":"WireIt.FormContainer",
      "type":"bolt",
      "icon":"/public/images/icons/bolt.png",
      "attributes":{
         "abstractionId":"filter",
         "class":"com.sinfonier.bolts.Filter"
      },
      "terminals":[
         {
            "name":"in[]",
            "nMaxWires":10,
            "offsetPosition":{
               "top":-15,
               "left":82
            },
            "ddConfig":{
               "type":"input",
               "allowedTypes":[
                  "output"
               ]
            },
            "direction":[
               0,
               -1
            ]
         },
         {
            "name":"out",
            "nMaxWires":10,
            "offsetPosition":{
               "bottom":-15,
               "left":82
            },
            "ddConfig":{
               "type":"output",
               "allowedTypes":[
                  "input"
               ]
            },
            "direction":[
               0,
               1
            ]
         }
      ]
   }
}